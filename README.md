# 初始化
go 初始化
```
go mod init itmrchow/go-project/user
```

# 安裝
```
gin
go get -u github.com/gin-gonic/gin

MySQL 安裝
go get -u github.com/go-sql-driver/mysql

ORM 安裝
go get -u gorm.io/gorm
go get -u gorm.io/driver/mysql

viper
go get github.com/spf13/viper

swagger
go install github.com/swaggo/swag/cmd/swag@latest
go get -u github.com/swaggo/gin-swagger
go get -u github.com/swaggo/files

UUID
go get github.com/google/uuid

unit test - testify
go get github.com/stretchr/testify

```

# goi18n 指令
```
goi18n extract -sourceLanguage en
goi18n merge active.en.toml active.es.toml //產生translate file
更新translate file後 , 修改檔名active.es.toml

```

# Go Style Decisions
https://google.github.io/styleguide/go/decisions.html

# Clean Architecture

- Entities - 核心邏輯
   - domain
     - helper - 簡單方法,不含狀態
- Use Cases - 商業邏輯
   - usecase
   - repo - 資料操作介面
- Interface Adapters - 對外界面來呼叫Use case
   - api
      - context (API response format)
      - controller (呼叫Usecase)
   - db
      - repo_impl
- Frameworks and Drivers - 框架，資料庫等等的把程式串起來的東西
   - router
   - db_handler (資料庫連線)

# swagger
https://github.com/go-swagger/go-swagger
https://github.com/swaggo/gin-swagger/tree/master

```
生產doc 指令
swag init 
```

# unit test
## testifi - assert & mock 工具包
https://github.com/stretchr/testify
## mockery - 快速產生介面相對應的mock

# wire - DI初始化

解決依賴注入初始化複雜問題

## 基礎
兩個核心概念, (提供者,providers) 和 (注入器,injectors)

### 提供者(Providers)
提供者是一個可以生產值的func

``` go
type Foo struct {
	X int
}

// ProvideFoo 是一個提供者
func ProvideFoo() Foo {
	return Foo{X: 42}
}

```
提供者可以指定依賴關係

``` go
type Bar struct {
	X int
}

// ProvideBar 指定依賴 Foo
func ProvideBar(foo Foo) Bar {
	return Bar{X: -foo.X}
}

```

提供者可以回傳Error
``` go
type Baz struct {
	X int
}

func ProvideBaz(ctx context.Context, bar Bar) (Baz, error) {
	if bar.X < 0 {
		return Baz{}, errors.New("cannot provide baz when bar is zero")
	}

	return Baz{X: bar.X}, nil
}

```

提供者可以被分組,變成提供者Set
可以使用wire.NewSet方法

``` go

var SuperSet = wire.NewSet(ProvideFoo, ProvideBar, ProvideBaz)

```

也可以把其他分好組的Set給Merge進來
``` go
// pkg.OtherSet 其他分好組的提供者Set
var MergeSet = wire.Newset(SuperSet, pkg.OtherSet)
```

### 注入(Injectors)
應用程式將提供者和注入器連接起來：用一個func依照依賴順序呼叫提供者
使用Wire只需要編寫注入器的簽名,Wire會產生func的主體

注入器 (injector) 的宣告方式是撰寫一個函式宣告，其函式主體為對 wire.Build 函式的呼叫
建構的回傳值只要符合正確的型別，本身的數值在生成的代碼中將會被忽略
``` go
// +build wireinject
// The build tag makes sure the stub is not built in the final build.

package main

import (
    "context"

    "github.com/google/wire"
    "example.com/foobarbaz"
)

func initializeBaz(ctx context.Context) (foobarbaz.Baz, error) {
    wire.Build(foobarbaz.MegaSet)
    return foobarbaz.Baz{}, nil
}

```
呼叫套件目錄中的 Wire 來產生注入器 wire_gen.go
``` shell
wire
```

wire_gen.go
``` go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

func initializeBaz(ctx context.Context) (foobarbaz.Baz, error) {
	foo := foobarbaz.ProvideFoo()
	bar := foobarbaz.ProvideBar(foo)
	baz, err := foobarbaz.ProvideBaz(ctx, bar)
	if err != nil {
		return foobarbaz.Baz{}, err
	}
	return baz, nil
}
```

## 進階使用
### 綁定介面
``` go
package foobarbaz

import "github.com/google/wire"

// 介面
type Fooer interface {
	Foo() string
}

// 實體
type MyFooer string

// 另一個實體
type BBar string

// MyFooer 實作 Fooer
func (b *MyFooer) Foo() string {
	return string(*b)
}

// MyFooer Provider
func provideMyFooer() *MyFooer {
	b := new(MyFooer)
	*b = "Hello, World!"
	return b
}

// BBar Provider , BBar 依賴 Fooer
func provideBBar(f Fooer) string {
	// f will be a *MyFooer.
	return f.Foo()
}

var Set = wire.NewSet(
	provideMyFooer,                       // MyFooer
	wire.Bind(new(Fooer), new(*MyFooer)), // Fooer介面綁MyFooer
	provideBBar)                          // 注入

```

# 錯誤處理
參考: https://ken00535.medium.com/go-error-handling-ebbd204bcdb4


# response format 




領域Error & API Error 
- 領域Error
- API Error: 接口端發生錯誤

## 參考
https://ken00535.medium.com/go-error-handling-ebbd204bcdb4

```

```




# Todo
- [x] swagger
- [x] UUID
- [x] unit test
- [ ] wire
- [ ] sturct to sturct
- [ ] response format
- [ ] error handle


# 參考
https://ithelp.ithome.com.tw/users/20120647/ironman/3110
https://dongstudio.medium.com/clean-architecture-%E4%BA%8C-%E6%95%B4%E6%BD%94%E5%BC%8F%E6%9E%B6%E6%A7%8B-be4010ee62d4
https://github.com/bxcodec/go-clean-arch?tab=readme-ov-file
https://dev.to/michinoins/building-a-crud-app-with-mysql-gorm-echo-and-clean-architecture-in-go-h6d
https://ken00535.medium.com/go-error-handling-ebbd204bcdb4
